Built-in Functions

-A
abs() aiter() all() any() anext() ascii()

abs(x)
Return the absolute value of a number. The argument may be an integer, a floating point number,
 or an object implementing __abs__(). If the argument is a complex number, its magnitude is returned.

aiter(async_iterable)
Return an asynchronous iterator for an asynchronous iterable. Equivalent to calling x.__aiter__().
aiter(x) itself has an __aiter__() method that returns x, so aiter(aiter(x)) is the same as aiter(x).
Note: Unlike iter(), aiter() has no 2-argument variant.
New in version 3.10.

all(iterable)
Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to:
def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
awaitable anext(async_iterator[, default])
When awaited, return the next item from the given asynchronous iterator, or default if given and the iterator is exhausted.
This is the async variant of the next() builtin, and behaves similarly.
This calls the __anext__() method of async_iterator, returning an awaitable. Awaiting this returns the next value of the iterator. 
If default is given, it is returned if the iterator is exhausted, otherwise StopAsyncIteration is raised.
New in version 3.10.

any(iterable)
Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to:
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False

ascii(object)
As repr(), return a string containing a printable representation of an object, but escape the non-ASCII characters in the 
string returned by repr() using \x, \u, or \U escapes. This generates a string similar to that returned by repr() in Python 2.


-----------------------------------------------------------------------------------------------------------------------------------


-B
bin() bool() breakpoint() bytearray() bytes()

bin(x)
Convert an integer number to a binary string prefixed with “0b”. The result is a valid Python expression. If x is not a Python
int object, it has to define an __index__() method that returns an integer. Some examples:
>>>
bin(3)
'0b11'
bin(-10)
'-0b1010'
If the prefix “0b” is desired or not, you can use either of the following ways.
>>>
format(14, '#b'), format(14, 'b')
('0b1110', '1110')
f'{14:#b}', f'{14:b}'
('0b1110', '1110')
See also format() for more information.

class bool([x])¶
Return a Boolean value, i.e. one of True or False. x is converted using the standard truth testing procedure. If x is false or omitted,
this returns False; otherwise, it returns True. The bool class is a subclass of int (see Numeric Types — int, float, complex). 
It cannot be subclassed further. Its only instances are False and True (see Boolean Values).

breakpoint(*args, **kws)
This function drops you into the debugger at the call site. Specifically, it calls sys.breakpointhook(), passing args and kws straight through. 
By default, sys.breakpointhook() calls pdb.set_trace() expecting no arguments.
In this case, it is purely a convenience function so you don’t have to explicitly import pdb or type as much code to enter the debugger. 
However, sys.breakpointhook() can be set to some other function and breakpoint() will automatically call that, allowing you to drop into the debugger 
of choice.

class bytearray([source[, encoding[, errors]]])
Return a new array of bytes. The bytearray class is a mutable sequence of integers in the range 0 <= x < 256. It has most of the usual methods of 
mutable sequences, described in Mutable Sequence Types, as well as most methods that the bytes type has, see Bytes and Bytearray Operations.
The optional source parameter can be used to initialize the array in a few different ways:
If it is a string, you must also give the encoding (and optionally, errors) parameters; bytearray() then converts the string to bytes using str.encode().
If it is an integer, the array will have that size and will be initialized with null bytes.
If it is an object conforming to the buffer interface, a read-only buffer of the object will be used to initialize the bytes array.
If it is an iterable, it must be an iterable of integers in the range 0 <= x < 256, which are used as the initial contents of the array.
Without an argument, an array of size 0 is created.

class bytes([source[, encoding[, errors]]])
Return a new “bytes” object which is an immutable sequence of integers in the range 0 <= x < 256. bytes is an immutable version of bytearray 
– it has the same non-mutating methods and the same indexing and slicing behavior.
Accordingly, constructor arguments are interpreted as for bytearray().
Bytes objects can also be created with literals, see String and Bytes literals.

----------------------------------------------------------------------------------------------------------------------------------------------------------

-C
callable() chr() classmethod() compile() complex()

class bytes([source[, encoding[, errors]]])
Return a new “bytes” object which is an immutable sequence of integers in the range 0 <= x < 256. bytes is an immutable version of bytearray 
– it has the same non-mutating methods and the same indexing and slicing behavior.
Accordingly, constructor arguments are interpreted as for bytearray().
Bytes objects can also be created with literals, see String and Bytes literals.

chr(i)
Return the string representing a character whose Unicode code point is the integer i. For example, chr(97) returns the string 'a', while chr(8364) 
returns the string '€'. This is the inverse of ord().
The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in base 16). ValueError will be raised if i is outside that range.

@classmethod
Transform a method into a class method.
A class method receives the class as an implicit first argument, just like an instance method receives the instance. To declare a class method, 
use this idiom:
class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ...
The @classmethod form is a function decorator – see Function definitions for details.
A class method can be called either on the class (such as C.f()) or on an instance (such as C().f()). The instance is ignored except for its class. 
If a class method is called for a derived class, the derived class object is passed as the implied first argument.
Class methods are different than C++ or Java static methods. If you want those, see staticmethod() in this section. For more information on class methods, 
see The standard type hierarchy.
Changed in version 3.9: Class methods can now wrap other descriptors such as property().
Changed in version 3.10: Class methods now inherit the method attributes (__module__, __name__, __qualname__, __doc__ and __annotations__) 
and have a new __wrapped__ attribute.

compile(source, filename, mode, flags=0, dont_inherit=False, optimize=- 1)
Compile the source into a code or AST object. Code objects can be executed by exec() or eval(). source can either be a normal string, a byte string, or 
an AST object. Refer to the ast module documentation for information on how to work with AST objects.
The filename argument should give the file from which the code was read; pass some recognizable value if it wasn’t read from a file ('<string>' is commonly used).
The mode argument specifies what kind of code must be compiled; it can be 'exec' if source consists of a sequence of statements, 'eval' if it consists of 
a single expression, or 'single' if it consists of a single interactive statement (in the latter case, expression statements that evaluate to something 
other than None will be printed).
The optional arguments flags and dont_inherit control which compiler options should be activated and which future features should be allowed. 
If neither is present (or both are zero) the code is compiled with the same flags that affect the code that is calling compile(). 
If the flags argument is given and dont_inherit is not (or is zero) then the compiler options and the future statements specified by the flags argument 
are used in addition to those that would be used anyway. If dont_inherit is a non-zero integer then the flags argument is it 
– the flags (future features and compiler options) in the surrounding code are ignored.
Compiler options and future statements are specified by bits which can be bitwise ORed together to specify multiple options. 
The bitfield required to specify a given future feature can be found as the compiler_flag attribute on the _Feature instance in the __future__ module. 
Compiler flags can be found in ast module, with PyCF_ prefix.
The argument optimize specifies the optimization level of the compiler; the default value of -1 selects the optimization level of the interpreter as given by -O options.
Explicit levels are 0 (no optimization; __debug__ is true), 1 (asserts are removed, __debug__ is false) or 2 (docstrings are removed too).
This function raises SyntaxError if the compiled source is invalid, and ValueError if the source contains null bytes.
If you want to parse Python code into its AST representation, see ast.parse().
Raises an auditing event compile with arguments source and filename. This event may also be raised by implicit compilation.
Note When compiling a string with multi-line code in 'single' or 'eval' mode, input must be terminated by at least one newline character. 
This is to facilitate detection of incomplete and complete statements in the code module.
Warning It is possible to crash the Python interpreter with a sufficiently large/complex string when compiling to an AST object due to stack depth limitations in Python’s AST compiler.

class complex([real[, imag]])
Return a complex number with the value real + imag*1j or convert a string or number to a complex number. If the first parameter is a string, 
it will be interpreted as a complex number and the function must be called without a second parameter. The second parameter can never be a string. 
Each argument may be any numeric type (including complex). If imag is omitted, it defaults to zero and the constructor serves as a numeric conversion 
like int and float. If both arguments are omitted, returns 0j.
For a general Python object x, complex(x) delegates to x.__complex__(). If __complex__() is not defined then it falls back to __float__(). 
If __float__() is not defined then it falls back to __index__().
Note When converting from a string, the string must not contain whitespace around the central + or - operator. For example, complex('1+2j') is fine, 
but complex('1 + 2j') raises ValueError.


-D
delattr() dict() dir() divmod()
-E
enumerate() eval() exec()
-F
filter() float() format() frozenset()
-G
getattr() globals()
-H
hasattr() hash() help() hex()
-I
id() input() int() isinstance() issubclass() iter()

-L
len() list() locals()

-M
map() max() memoryview() min()

-N
next()

-O
object() oct() open() ord()

-P
pow() print() property()

-R
range() repr() reversed() round()

-S
set() setattr() slice() sorted() staticmethod() str() sum() super()

-T
tuple() type()

-V
vars()

-Z
zip()

_
__import__()